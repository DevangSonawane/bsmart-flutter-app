# üöÄ Implementation Guide - Story Fixes

## Quick Start

### Step 1: Backup Your Files
```bash
cp lib/screens/story_editing_screen.dart lib/screens/story_editing_screen.dart.backup
cp lib/screens/story_camera_screen.dart lib/screens/story_camera_screen.dart.backup
cp lib/api/stories_api.dart lib/api/stories_api.dart.backup
```

### Step 2: Apply the Fixes

#### Option A: Replace the Entire File (Recommended)
1. Copy `story_editing_screen_FIXED.dart` to `lib/screens/story_editing_screen.dart`
2. Done!

#### Option B: Manual Patching (If you have custom changes)
Apply these specific changes to your existing files:

---

## üìù Manual Patch Instructions

### File 1: `lib/screens/story_editing_screen.dart`

#### Change 1: Add error state variable (Line 31)
```dart
// OLD:
bool _imageReady = false;

// NEW:
bool _imageReady = false;
bool _imageError = false;
```

#### Change 2: Fix precaching method (Lines 38-46)
```dart
// OLD:
void _precacheCurrent() {
  final img = widget.media[_currentIndex];
  final stream = img.resolve(const ImageConfiguration());
  stream.addListener(ImageStreamListener((_, __) {
    if (mounted) setState(() => _imageReady = true);
  }, onError: (_, __) {
    if (mounted) setState(() => _imageReady = false);
  }));
}

// NEW:
void _precacheCurrent() async {
  final img = widget.media[_currentIndex];
  try {
    await precacheImage(
      img,
      context,
      size: const Size(1080, 1920),
    );
    if (mounted) {
      setState(() {
        _imageReady = true;
        _imageError = false;
      });
    }
  } catch (e) {
    print('Image precache error: $e');
    if (mounted) {
      setState(() {
        _imageReady = false;
        _imageError = true;
      });
    }
  }
}
```

#### Change 3: Fix image display (Line 217)
```dart
// OLD:
Positioned.fill(child: Image(image: currentImage, fit: BoxFit.cover)),

// NEW:
Positioned.fill(
  child: _imageError
      ? Container(
          color: Colors.black,
          child: const Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.error_outline, color: Colors.white, size: 48),
                SizedBox(height: 16),
                Text('Failed to load image', style: TextStyle(color: Colors.white)),
              ],
            ),
          ),
        )
      : _imageReady
          ? Image(image: currentImage, fit: BoxFit.cover)
          : Container(
              color: Colors.black,
              child: const Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    CircularProgressIndicator(color: Colors.white),
                    SizedBox(height: 16),
                    Text('Loading image...', style: TextStyle(color: Colors.white)),
                  ],
                ),
              ),
            ),
),
```

#### Change 4: Add imports at the top
```dart
import 'dart:async';
import 'dart:io';
```

#### Change 5: Replace entire `_postToApi` method (Lines 118-173)
```dart
Future<void> _postToApi() async {
  try {
    // Validation
    if (!_imageReady) {
      _showError('Image is still loading');
      return;
    }

    if (_imageError) {
      _showError('Image failed to load. Please try again.');
      return;
    }

    // Check network connectivity
    if (!await _checkConnectivity()) {
      _showError('No internet connection. Please check your network.');
      return;
    }

    final boundary = _repaintKey.currentContext?.findRenderObject() as RenderRepaintBoundary?;
    if (boundary == null) {
      _showError('Unable to capture story');
      return;
    }

    // Show loading indicator
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(color: Colors.white, strokeWidth: 2),
              ),
              SizedBox(width: 16),
              Text('Posting story...'),
            ],
          ),
          duration: Duration(seconds: 30),
        ),
      );
    }

    // Capture image
    final ui.Image image = await boundary.toImage(pixelRatio: 2.0);
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);

    if (byteData == null) {
      _showError('Failed to capture image');
      return;
    }

    final bytes = byteData.buffer.asUint8List();

    // Upload with retry
    print('üì§ Uploading story image...');
    final upload = await _uploadWithRetry(
      bytes.toList(),
      'story_${DateTime.now().millisecondsSinceEpoch}.png',
    );

    print('Upload response: $upload');

    // Extract URL with validation
    String? url;
    if (upload is Map) {
      url = upload['fileUrl'] as String? ??
          upload['url'] as String? ??
          upload['file_url'] as String?;

      // Check nested data object
      if (url == null && upload['data'] is Map) {
        final data = upload['data'] as Map;
        url = data['url'] as String? ??
            data['fileUrl'] as String? ??
            data['file_url'] as String?;
      }
    }

    // Validate URL
    if (url == null || url.isEmpty) {
      print('‚ùå Upload failed - no URL in response: $upload');
      _showError('Upload failed: No URL returned');
      return;
    }

    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      print('‚ùå Invalid URL format: $url');
      _showError('Upload failed: Invalid URL format');
      return;
    }

    print('‚úÖ Image uploaded: $url');

    // Get screen size for calculating relative positions
    final screenSize = MediaQuery.of(context).size;

    // Create payload matching API documentation
    final payload = {
      'media': {
        'url': url,
        'type': 'image',
        'width': image.width,
        'height': image.height,
      },
      'transform': {
        'x': 0.5,
        'y': 0.5,
        'scale': 1.0,
        'rotation': 0.0,
      },
      'filter': {
        'name': 'none',
        'intensity': 0,
      },
      'texts': _elements
          .where((e) => e.type == _ElementType.text)
          .map((e) {
            final colorHex = '#${(e.color ?? Colors.white).value.toRadixString(16).substring(2, 8).toUpperCase()}';
            return {
              'content': e.text ?? '',
              'fontSize': 24,
              'fontFamily': (e.style ?? 'classic').toLowerCase(),
              'color': colorHex,
              'align': 'center',
              'x': e.position.dx / screenSize.width,
              'y': e.position.dy / screenSize.height,
            };
          })
          .toList(),
      'mentions': [],
    };

    print('üì§ Posting to API with payload: $payload');

    // Post to API
    final response = await StoriesApi().create([payload]);

    print('‚úÖ Story posted successfully: $response');

    if (mounted) {
      ScaffoldMessenger.of(context).clearSnackBars();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Posted to story ‚úì'),
          backgroundColor: Colors.green,
        ),
      );
      Navigator.pop(context, true);
    }
  } on SocketException {
    print('‚ùå Network error');
    _showError('No internet connection');
  } on TimeoutException {
    print('‚ùå Timeout error');
    _showError('Request timed out. Please try again.');
  } catch (e, stackTrace) {
    print('‚ùå Error posting story: $e');
    print('Stack trace: $stackTrace');

    if (mounted) {
      ScaffoldMessenger.of(context).clearSnackBars();
      String errorMessage = 'Failed to post story';

      if (e is ApiException) {
        errorMessage = e.message;
      }

      _showError(errorMessage);
    }
  }
}
```

#### Change 6: Add helper methods after `_postToApi`
```dart
Future<Map<String, dynamic>> _uploadWithRetry(
  List<int> bytes,
  String filename, {
  int maxRetries = 3,
}) async {
  int attempts = 0;
  Exception? lastException;

  while (attempts < maxRetries) {
    try {
      attempts++;
      print('Upload attempt $attempts of $maxRetries');
      
      final upload = await UploadApi().uploadFileBytes(
        bytes: bytes,
        filename: filename,
      );
      
      return upload;
    } catch (e) {
      print('Upload attempt $attempts failed: $e');
      lastException = e as Exception;

      if (attempts < maxRetries) {
        final delaySeconds = attempts * 2;
        print('Retrying in $delaySeconds seconds...');
        await Future.delayed(Duration(seconds: delaySeconds));
      }
    }
  }

  throw lastException ?? Exception('Upload failed after $maxRetries attempts');
}

Future<bool> _checkConnectivity() async {
  try {
    final result = await InternetAddress.lookup('google.com')
        .timeout(const Duration(seconds: 5));
    return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
  } catch (_) {
    return false;
  }
}

void _showError(String message) {
  if (!mounted) return;
  
  ScaffoldMessenger.of(context).clearSnackBars();
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: Colors.red,
      duration: const Duration(seconds: 5),
      action: SnackBarAction(
        label: 'Retry',
        textColor: Colors.white,
        onPressed: _postToApi,
      ),
    ),
  );
}
```

---

### File 2: `lib/screens/story_camera_screen.dart`

#### Change: Update `_capturePhoto` method (Lines 286-326)
```dart
// Find this section and update it:

Future<void> _capturePhoto() async {
  try {
    if (_controller == null || !_controller!.value.isInitialized) return;
    if (_controller!.value.isTakingPicture || _controller!.value.isRecordingVideo) return;
    
    if (_focusPoint != null) {
      final size = MediaQuery.of(context).size;
      final nx = _focusPoint!.dx / size.width;
      final ny = _focusPoint!.dy / size.height;
      await _controller!.setFocusPoint(Offset(nx, ny)).catchError((_) {});
    }
    
    await Future.delayed(const Duration(milliseconds: 120));
    
    XFile xfile;
    try {
      xfile = await _controller!.takePicture();
    } catch (_) {
      await _selectAndInitCamera(_useFrontCamera ? CameraLensDirection.front : CameraLensDirection.back);
      await Future.delayed(const Duration(milliseconds: 300));
      xfile = await _controller!.takePicture();
    }
    
    final imgProvider = FileImage(File(xfile.path));
    
    // ADDED: Precache before navigation
    if (mounted) {
      await precacheImage(imgProvider, context);
    }
    
    setState(() => _lastThumb = imgProvider);
    
    if (_mode == 'POST') {
      Navigator.of(context).push(
        MaterialPageRoute(
          builder: (context) => CreateEditPreviewScreen(
            media: MediaItem(
              id: DateTime.now().millisecondsSinceEpoch.toString(),
              type: MediaType.image,
              filePath: xfile.path,
              createdAt: DateTime.now(),
            ),
          ),
        ),
      );
    } else {
      // Navigate after precaching
      if (mounted) {
        Navigator.of(context).push(
          MaterialPageRoute(builder: (_) => StoryEditingScreen(media: [imgProvider])),
        );
      }
    }
  } catch (e) {
    print('Capture error: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Failed to capture')),
    );
  }
}
```

---

### File 3: `lib/api/stories_api.dart`

#### Change: Simplify create methods (Lines 37-65)
```dart
// Replace the existing create and createFlexible methods with:

Future<Map<String, dynamic>> create(List<Map<String, dynamic>> itemsPayload) async {
  final body = {'items': itemsPayload};
  print('Creating story with body: $body'); // Debug log
  final res = await _client.post(_path('/stories'), body: body);
  return (res as Map).cast<String, dynamic>();
}

Future<Map<String, dynamic>> createFlexible(List<Map<String, dynamic>> itemsPayload) async {
  try {
    return await create(itemsPayload);
  } catch (e) {
    print('Story creation failed: $e');
    rethrow; // Don't swallow errors
  }
}
```

---

## üß™ Testing Steps

After applying the fixes:

### Test 1: Black Screen Fix
1. Open the app
2. Go to camera
3. Take a photo
4. **Expected:** Loading indicator appears briefly, then image shows
5. **NOT Expected:** Black screen

### Test 2: Story Posting
1. Take a photo
2. Add some text or drawing
3. Tap "Your Story"
4. **Expected:** 
   - "Posting story..." message appears
   - After a few seconds: "Posted to story ‚úì"
   - Returns to previous screen
5. **Check:** Story appears in your feed

### Test 3: Error Handling
1. Turn off WiFi/mobile data
2. Try to post a story
3. **Expected:** "No internet connection" error with Retry button
4. Turn on internet
5. Tap Retry
6. **Expected:** Story posts successfully

### Test 4: Large Images
1. Pick a high-resolution photo from gallery
2. Post as story
3. **Expected:** Upload succeeds (may take longer)

---

## üêõ If Issues Persist

### Check Console Logs
Look for these messages:
```
üì§ Uploading story image...
Upload attempt 1 of 3
Upload response: {...}
‚úÖ Image uploaded: https://...
üì§ Posting to API with payload: {...}
‚úÖ Story posted successfully: {...}
```

### Common Issues

**Issue: "Upload failed: No URL returned"**
- Check your upload API endpoint
- Verify the response format from `/api/upload`
- Run this curl test:
```bash
curl -X POST YOUR_API_URL/api/upload \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@test.jpg"
```

**Issue: Still getting black screen**
- Clear app cache: `flutter clean`
- Rebuild: `flutter pub get && flutter run`
- Check if image file exists: Add `print('File exists: ${File(xfile.path).existsSync()}');`

**Issue: API returns 400 Bad Request**
- Check payload structure matches API docs
- Verify all required fields are present
- Check API logs on backend

**Issue: Timeout errors**
- Increase timeout in `api_config.dart`
- Check network speed
- Try uploading smaller images

---

## ‚úÖ Success Checklist

- [ ] No black screen when opening edit screen
- [ ] Loading indicator shows while image loads
- [ ] Can post story with text
- [ ] Can post story with drawings  
- [ ] Error messages show properly
- [ ] Retry button works
- [ ] Story appears in feed
- [ ] Console logs show debug info
- [ ] No crashes or exceptions

---

## üìû Need Help?

If you're still having issues:

1. **Share your console logs** - Copy the entire output from when you tap the camera button to when the error occurs

2. **Share API response** - Look for the log: `Upload response: {...}` and share that

3. **Check backend logs** - See if the POST to `/api/stories` is reaching your server

4. **Test the API directly** - Use Postman or curl to verify the API works:
```bash
# Test upload
curl -X POST YOUR_API/api/upload \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@photo.jpg"

# Test story creation
curl -X POST YOUR_API/api/stories \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "items": [{
      "media": {"url": "UPLOADED_URL", "type": "image"},
      "transform": {"x": 0.5, "y": 0.5, "scale": 1, "rotation": 0},
      "filter": {"name": "none", "intensity": 0},
      "texts": [],
      "mentions": []
    }]
  }'
```

Good luck! üöÄ