# B-Smart Flutter App - Story Issues Analysis & Fixes

## ðŸ” Issues Identified

### Issue #1: Black Screen in Story Editing Screen
**Location:** `lib/screens/story_editing_screen.dart`

#### Root Cause:
The black screen issue occurs because the image is not being loaded/displayed properly when navigating to the `StoryEditingScreen`. The problem is in the image precaching and display mechanism.

**Problems Found:**

1. **Image Precaching Logic** (Lines 38-46):
   ```dart
   void _precacheCurrent() {
     final img = widget.media[_currentIndex];
     final stream = img.resolve(const ImageConfiguration());
     stream.addListener(ImageStreamListener((_, __) {
       if (mounted) setState(() => _imageReady = true);
     }, onError: (_, __) {
       if (mounted) setState(() => _imageReady = false);
     }));
   }
   ```
   - The `ImageStreamListener` is not being properly removed, which can cause memory leaks
   - The `ImageConfiguration` is empty, which doesn't provide proper context for image resolution
   - The `_imageReady` flag starts as `false` and only becomes `true` after the listener fires, causing a black screen during loading

2. **Image Display** (Line 217):
   ```dart
   Positioned.fill(child: Image(image: currentImage, fit: BoxFit.cover)),
   ```
   - No loading indicator or placeholder is shown while the image is loading
   - No error handling if the image fails to load
   - The widget rebuilds but the image may not be ready yet

3. **Navigation from Camera** (`story_camera_screen.dart`, Line 321):
   ```dart
   Navigator.of(context).push(MaterialPageRoute(builder: (_) => StoryEditingScreen(media: [imgProvider])));
   ```
   - The `FileImage` is created but not precached before navigation
   - No verification that the file exists or is readable

#### Solutions:

**Fix #1: Improve Image Precaching**
```dart
void _precacheCurrent() async {
  final img = widget.media[_currentIndex];
  try {
    // Precache with proper configuration
    await precacheImage(
      img,
      context,
      size: const Size(1080, 1920), // Story aspect ratio
    );
    if (mounted) setState(() => _imageReady = true);
  } catch (e) {
    print('Image precache error: $e');
    if (mounted) setState(() => _imageReady = false);
  }
}
```

**Fix #2: Add Loading State to UI**
Replace line 217 with:
```dart
Positioned.fill(
  child: _imageReady
      ? Image(image: currentImage, fit: BoxFit.cover)
      : Container(
          color: Colors.black,
          child: const Center(
            child: CircularProgressIndicator(
              color: Colors.white,
            ),
          ),
        ),
),
```

**Fix #3: Add Error Boundary**
Add this after line 217:
```dart
if (!_imageReady)
  Positioned.fill(
    child: Container(
      color: Colors.black,
      child: const Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, color: Colors.white, size: 48),
            SizedBox(height: 16),
            Text('Loading image...', style: TextStyle(color: Colors.white)),
          ],
        ),
      ),
    ),
  ),
```

**Fix #4: Precache Before Navigation** (in `story_camera_screen.dart`):
```dart
Future<void> _capturePhoto() async {
  try {
    // ... existing code ...
    final imgProvider = FileImage(File(xfile.path));
    
    // Precache before setting thumb
    await precacheImage(imgProvider, context);
    
    setState(() => _lastThumb = imgProvider);
    
    if (_mode == 'POST') {
      // ... existing code ...
    } else {
      // Navigate after precaching
      if (mounted) {
        Navigator.of(context).push(
          MaterialPageRoute(
            builder: (_) => StoryEditingScreen(media: [imgProvider]),
          ),
        );
      }
    }
  } catch (e) {
    print('Capture error: $e');
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Failed to capture')),
    );
  }
}
```

---

### Issue #2: Story Posting Failures
**Location:** `lib/screens/story_editing_screen.dart` (Lines 110-173)

#### Root Causes:

1. **Missing Await for Upload** (Line 136):
   ```dart
   final upload = await UploadApi().uploadFileBytes(bytes: bytes.toList(), filename: 'story.png');
   ```
   - The upload might be failing silently
   - No proper error handling for upload failures
   - No retry mechanism

2. **Inconsistent URL Extraction** (Lines 137-141):
   ```dart
   final url = (upload['fileUrl'] as String?) ??
       (upload['url'] as String?) ??
       (upload['file_url'] as String?) ??
       (upload['data'] is Map ? (upload['data']['url'] as String?) : null) ??
       '';
   ```
   - Too many fallbacks suggest the backend response is inconsistent
   - No validation that the URL is actually a valid HTTP URL

3. **Payload Structure Mismatch** (Lines 146-161):
   The payload being sent doesn't match the API documentation exactly:
   
   **Current payload:**
   ```dart
   final payload = {
     'media': {'url': url, 'type': 'image'},
     'transform': {'x': 0.5, 'y': 0.5, 'scale': 1, 'rotation': 0},
     'filter': {'name': 'none', 'intensity': 0},
     'texts': [...],
     'mentions': [],
   };
   ```
   
   **API expects (from documentation):**
   ```json
   {
     "items": [
       {
         "media": {"url": "...", "type": "image"},
         "transform": {...},
         "filter": {...},
         "texts": [...],
         "mentions": [...]
       }
     ]
   }
   ```
   
   The current code calls `createFlexible([payload])` which wraps it in an array, but this might not match what the backend expects.

4. **API Method Issues** (`lib/api/stories_api.dart`, Lines 42-65):
   ```dart
   Future<Map<String, dynamic>> createFlexible(List<Map<String, dynamic>> itemsPayload) async {
     try {
       return await create(itemsPayload);  // Tries POST /api/stories with {"items": [...]}
     } catch (e) {
       try {
         final res = await _client.post(_path('/stories/create'), body: {'items': itemsPayload});
         return (res as Map).cast<String, dynamic>();
       } catch (_) {
         // More fallbacks...
       }
     }
   }
   ```
   - Too many fallback attempts suggest the API contract is unclear
   - The `_path('/stories/create')` endpoint doesn't exist in the API documentation
   - Multiple error swallowing with `catch (_)` hides real issues

5. **Missing Image Size in Payload**:
   According to the API docs, the media object can include:
   ```json
   {
     "url": "...",
     "type": "image",
     "width": 1080,
     "height": 1920
   }
   ```
   But the current implementation doesn't include width/height.

#### Solutions:

**Fix #1: Improve Upload Error Handling**
```dart
Future<void> _postToApi() async {
  try {
    if (!_imageReady) {
      _showError('Image is still loading');
      return;
    }
    
    final boundary = _repaintKey.currentContext?.findRenderObject() as RenderRepaintBoundary?;
    if (boundary == null) {
      _showError('Unable to capture story');
      return;
    }
    
    // Show loading indicator
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              CircularProgressIndicator(color: Colors.white),
              SizedBox(width: 16),
              Text('Posting story...'),
            ],
          ),
          duration: Duration(seconds: 30),
        ),
      );
    }
    
    final ui.Image image = await boundary.toImage(pixelRatio: 2.0);
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    
    if (byteData == null) {
      _showError('Failed to capture image');
      return;
    }
    
    final bytes = byteData.buffer.asUint8List();
    
    // Upload with better error handling
    final upload = await UploadApi().uploadFileBytes(
      bytes: bytes.toList(),
      filename: 'story_${DateTime.now().millisecondsSinceEpoch}.png',
    );
    
    print('Upload response: $upload'); // Debug log
    
    // Better URL extraction with validation
    String? url;
    if (upload is Map) {
      url = upload['fileUrl'] as String? ??
            upload['url'] as String? ??
            upload['file_url'] as String?;
      
      // Check nested data object
      if (url == null && upload['data'] is Map) {
        final data = upload['data'] as Map;
        url = data['url'] as String? ??
              data['fileUrl'] as String? ??
              data['file_url'] as String?;
      }
    }
    
    // Validate URL
    if (url == null || url.isEmpty) {
      print('Upload response: $upload'); // Debug
      _showError('Upload failed: No URL returned');
      return;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      _showError('Upload failed: Invalid URL format');
      return;
    }
    
    // Get image dimensions
    final width = image.width;
    final height = image.height;
    
    // Create proper payload matching API documentation
    final payload = {
      'media': {
        'url': url,
        'type': 'image',
        'width': width,
        'height': height,
      },
      'transform': {
        'x': 0.5,
        'y': 0.5,
        'scale': 1.0,
        'rotation': 0.0,
      },
      'filter': {
        'name': 'none',
        'intensity': 0,
      },
      'texts': _elements
          .where((e) => e.type == _ElementType.text)
          .map((e) => {
                'content': e.text ?? '',
                'fontSize': 24,
                'fontFamily': (e.style ?? 'classic').toLowerCase(),
                'color': '#${(e.color ?? Colors.white).value.toRadixString(16).substring(2, 8).toUpperCase()}',
                'align': 'center',
                'x': e.position.dx / MediaQuery.of(context).size.width,
                'y': e.position.dy / MediaQuery.of(context).size.height,
              })
          .toList(),
      'mentions': [], // Could extract from _elements if needed
    };
    
    print('Posting payload: $payload'); // Debug log
    
    // Use the correct API method
    final response = await StoriesApi().create([payload]);
    
    print('Story response: $response'); // Debug log
    
    if (mounted) {
      ScaffoldMessenger.of(context).clearSnackBars();
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Posted to story âœ“')),
      );
      Navigator.pop(context, true); // Pass true to indicate success
    }
  } catch (e, stackTrace) {
    print('Error posting story: $e');
    print('Stack trace: $stackTrace');
    
    if (mounted) {
      ScaffoldMessenger.of(context).clearSnackBars();
      String errorMessage = 'Failed to post story';
      
      if (e is ApiException) {
        errorMessage = e.message;
      } else if (e is SocketException) {
        errorMessage = 'No internet connection';
      } else if (e is TimeoutException) {
        errorMessage = 'Request timed out';
      }
      
      _showError(errorMessage);
    }
  }
}

void _showError(String message) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: Colors.red,
      action: SnackBarAction(
        label: 'Retry',
        textColor: Colors.white,
        onPressed: _postToApi,
      ),
    ),
  );
}
```

**Fix #2: Simplify API Method**
In `lib/api/stories_api.dart`, replace `createFlexible` with a simpler version:
```dart
Future<Map<String, dynamic>> create(List<Map<String, dynamic>> itemsPayload) async {
  final body = {'items': itemsPayload};
  print('Creating story with body: $body'); // Debug log
  final res = await _client.post(_path('/stories'), body: body);
  return (res as Map).cast<String, dynamic>();
}

// Remove createFlexible or make it truly flexible with better error messages
Future<Map<String, dynamic>> createFlexible(List<Map<String, dynamic>> itemsPayload) async {
  try {
    return await create(itemsPayload);
  } catch (e) {
    print('Story creation failed: $e');
    // Don't swallow the error - rethrow it
    rethrow;
  }
}
```

---

## ðŸ”§ Additional Improvements

### 1. Add Validation Before Posting
```dart
bool _validateStory() {
  if (!_imageReady) {
    _showError('Please wait for image to load');
    return false;
  }
  
  if (_elements.isEmpty && _strokes.isEmpty) {
    // Ask user if they want to post without edits
    return true;
  }
  
  return true;
}
```

### 2. Add Retry Logic for Upload
```dart
Future<Map<String, dynamic>> _uploadWithRetry(List<int> bytes, String filename, {int maxRetries = 3}) async {
  int attempts = 0;
  Exception? lastException;
  
  while (attempts < maxRetries) {
    try {
      attempts++;
      final upload = await UploadApi().uploadFileBytes(
        bytes: bytes,
        filename: filename,
      );
      return upload;
    } catch (e) {
      print('Upload attempt $attempts failed: $e');
      lastException = e as Exception;
      
      if (attempts < maxRetries) {
        await Future.delayed(Duration(seconds: attempts * 2)); // Exponential backoff
      }
    }
  }
  
  throw lastException ?? Exception('Upload failed after $maxRetries attempts');
}
```

### 3. Add Network Connectivity Check
```dart
Future<bool> _checkConnectivity() async {
  try {
    final result = await InternetAddress.lookup('google.com');
    return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
  } catch (_) {
    return false;
  }
}

Future<void> _postToApi() async {
  // Add at the start
  if (!await _checkConnectivity()) {
    _showError('No internet connection. Please check your network.');
    return;
  }
  // ... rest of the code
}
```

### 4. Add Image Compression
Large images can cause upload failures. Add compression:
```dart
import 'package:flutter_image_compress/flutter_image_compress.dart';

Future<List<int>> _compressImage(List<int> bytes) async {
  final compressed = await FlutterImageCompress.compressWithList(
    bytes,
    minWidth: 1080,
    minHeight: 1920,
    quality: 85,
    format: CompressFormat.jpeg,
  );
  return compressed;
}

// Use in _postToApi:
final bytes = byteData.buffer.asUint8List();
final compressedBytes = await _compressImage(bytes);
final upload = await _uploadWithRetry(compressedBytes, filename);
```

---

## ðŸ“ Summary of Changes Needed

### Files to Modify:

1. **`lib/screens/story_editing_screen.dart`**
   - Fix image precaching logic
   - Add loading state UI
   - Improve error handling in `_postToApi`
   - Add validation before posting
   - Add retry logic
   - Fix payload structure

2. **`lib/screens/story_camera_screen.dart`**
   - Add image precaching before navigation
   - Improve error handling in `_capturePhoto`

3. **`lib/api/stories_api.dart`**
   - Simplify `createFlexible` method
   - Remove unnecessary fallbacks
   - Add debug logging

4. **`pubspec.yaml`** (if not already added)
   - Add `flutter_image_compress: ^2.1.0` for image compression

---

## ðŸ§ª Testing Checklist

After implementing fixes:

- [ ] Test taking a photo and opening edit screen (should not show black screen)
- [ ] Test that loading indicator appears while image loads
- [ ] Test posting a story with text overlays
- [ ] Test posting a story with drawings
- [ ] Test posting a story without any edits
- [ ] Test error handling with no internet connection
- [ ] Test error handling with invalid API response
- [ ] Test uploading large images (>5MB)
- [ ] Test rapid consecutive posts
- [ ] Verify story appears in feed after posting
- [ ] Check console logs for any errors

---

## ðŸ” Debugging Tips

1. **Enable Debug Logging:**
   Add these print statements to track the flow:
   ```dart
   print('ðŸ“¸ Capturing photo...');
   print('â¬†ï¸ Uploading image...');
   print('âœ… Upload complete: $url');
   print('ðŸ“¤ Posting to API...');
   print('âœ“ Story posted successfully');
   ```

2. **Check API Response:**
   Log the full API response to see what the backend is actually returning:
   ```dart
   print('Full upload response: ${jsonEncode(upload)}');
   print('Full story response: ${jsonEncode(response)}');
   ```

3. **Monitor Network Calls:**
   Use Flutter DevTools Network tab to see actual HTTP requests and responses

4. **Test with Sample Image:**
   Add a button to load a test image from assets to isolate camera issues:
   ```dart
   final testImage = AssetImage('assets/test_story.jpg');
   Navigator.push(
     context,
     MaterialPageRoute(
       builder: (_) => StoryEditingScreen(media: [testImage]),
     ),
   );
   ```

---

## ðŸš€ Quick Fix Priority

**High Priority (Fix Immediately):**
1. Image precaching before navigation âš ï¸
2. Loading state in edit screen âš ï¸
3. Better error messages for API failures âš ï¸
4. Payload structure matching API docs âš ï¸

**Medium Priority (Fix Soon):**
5. Upload retry logic
6. Network connectivity check
7. Image compression

**Low Priority (Nice to Have):**
8. Advanced validation
9. Progress indicators
10. Offline support

---

## ðŸ“ž Support

If issues persist after implementing these fixes:

1. Check Flutter version: `flutter --version` (should be >= 3.0.0)
2. Check dependencies: `flutter pub get`
3. Clean and rebuild: `flutter clean && flutter pub get && flutter run`
4. Enable verbose logging: `flutter run -v`
5. Check backend API logs for any server-side errors
6. Verify the upload endpoint is working with a curl test:
   ```bash
   curl -X POST http://YOUR_API/api/upload \
     -H "Authorization: Bearer YOUR_TOKEN" \
     -F "file=@test.jpg"
   ```

---

**Document Version:** 1.0
**Date:** February 13, 2026
**Status:** Ready for Implementation